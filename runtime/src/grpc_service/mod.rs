//! gRPC service implementation for high-performance remote pipeline execution
//!
//! This module provides a gRPC service that exposes the Rust runtime's audio pipeline
//! execution capabilities with <5ms latency and support for 1000+ concurrent connections.
//!
//! # Architecture
//!
//! - **server.rs**: Tonic server setup with middleware (auth, metrics, logging)
//! - **execution.rs**: Unary RPC handler for ExecutePipeline
//! - **streaming.rs**: Bidirectional streaming handler for StreamPipeline
//! - **auth.rs**: API token validation middleware
//! - **limits.rs**: Resource limit enforcement
//! - **metrics.rs**: Prometheus metrics collection
//! - **version.rs**: Protocol version negotiation
//!
//! # Protocol Buffers
//!
//! Generated from `runtime/protos/*.proto`:
//! - common.proto: AudioBuffer, ExecutionMetrics, ErrorResponse
//! - execution.proto: PipelineExecutionService, ExecutePipeline RPC
//! - streaming.proto: StreamingPipelineService, StreamPipeline RPC
//!
//! # Features
//!
//! This module is only compiled when the `grpc-transport` feature is enabled.

#![cfg(feature = "grpc-transport")]

// Submodules (implementation to be added in Phase 2 & 3)
pub mod auth;
pub mod execution;
pub mod limits;
pub mod metrics;
pub mod server;
pub mod streaming;
pub mod version;

// Re-export generated protobuf types
// Generated by tonic-build in build.rs
pub mod generated {
    // Include generated code from build.rs output
    // This will be populated after first cargo build
    tonic::include_proto!("remotemedia.v1");
}

// Re-export key types for convenience
pub use generated::{
    AudioBuffer, AudioFormat, ErrorResponse, ErrorType, ExecutionMetrics, ExecutionStatus,
    NodeMetrics, NodeResult, NodeStatus, ResourceLimits, VersionInfo,
};

// Service traits
pub use generated::{
    pipeline_execution_service_server::{PipelineExecutionService, PipelineExecutionServiceServer},
    streaming_pipeline_service_server::{
        StreamingPipelineService, StreamingPipelineServiceServer,
    },
};

/// Error type for gRPC service operations
#[derive(Debug, thiserror::Error)]
pub enum ServiceError {
    #[error("Validation error: {0}")]
    Validation(String),

    #[error("Node execution error in {node_id}: {message}")]
    NodeExecution { node_id: String, message: String },

    #[error("Resource limit exceeded: {0}")]
    ResourceLimit(String),

    #[error("Authentication failed: {0}")]
    Authentication(String),

    #[error("Version mismatch: {0}")]
    VersionMismatch(String),

    #[error("Internal error: {0}")]
    Internal(String),
}

impl From<ServiceError> for tonic::Status {
    fn from(err: ServiceError) -> Self {
        use tonic::Code;
        match err {
            ServiceError::Validation(msg) => tonic::Status::new(Code::InvalidArgument, msg),
            ServiceError::NodeExecution { node_id, message } => {
                tonic::Status::new(Code::Internal, format!("Node {}: {}", node_id, message))
            }
            ServiceError::ResourceLimit(msg) => tonic::Status::new(Code::ResourceExhausted, msg),
            ServiceError::Authentication(msg) => tonic::Status::new(Code::Unauthenticated, msg),
            ServiceError::VersionMismatch(msg) => {
                tonic::Status::new(Code::FailedPrecondition, msg)
            }
            ServiceError::Internal(msg) => tonic::Status::new(Code::Internal, msg),
        }
    }
}

impl ServiceError {
    /// Convert to protobuf ErrorResponse
    pub fn to_proto(&self, node_id: Option<String>) -> ErrorResponse {
        let (error_type, message) = match self {
            ServiceError::Validation(msg) => (ErrorType::ValidationError as i32, msg.clone()),
            ServiceError::NodeExecution {
                node_id: _,
                message,
            } => (ErrorType::NodeExecutionError as i32, message.clone()),
            ServiceError::ResourceLimit(msg) => (ErrorType::ResourceLimitError as i32, msg.clone()),
            ServiceError::Authentication(msg) => {
                (ErrorType::AuthenticationError as i32, msg.clone())
            }
            ServiceError::VersionMismatch(msg) => {
                (ErrorType::VersionMismatchError as i32, msg.clone())
            }
            ServiceError::Internal(msg) => (ErrorType::InternalError as i32, msg.clone()),
        };

        ErrorResponse {
            error_type,
            message,
            failing_node_id: node_id.unwrap_or_default(),
            context: String::new(), // Will be populated by caller
            stack_trace: String::new(),
        }
    }
}
