// Test that manifests generated by Python SDK can be parsed by Rust runtime

use remotemedia_runtime::manifest::{parse, validate};

#[test]
fn test_parse_python_generated_manifest() {
    // This is an example manifest that Python SDK would generate
    let manifest_json = r#"{
  "version": "v1",
  "metadata": {
    "name": "test-pipeline",
    "description": "Test pipeline from Python",
    "created_at": "2025-10-22T12:00:00Z"
  },
  "nodes": [
    {
      "id": "input_0",
      "node_type": "DataSourceNode",
      "params": {}
    },
    {
      "id": "transform_1",
      "node_type": "AudioTransform",
      "params": {
        "effect": "normalize"
      },
      "capabilities": {
        "cpu": {
          "cores": 2
        },
        "memory_gb": 1.0
      }
    },
    {
      "id": "whisper_2",
      "node_type": "WhisperTranscriptionNode",
      "params": {
        "model_id": "openai/whisper-large-v3-turbo",
        "device": "cuda"
      },
      "capabilities": {
        "gpu": {
          "type": "cuda",
          "min_memory_gb": 6.0,
          "required": true
        },
        "memory_gb": 8.0
      },
      "host": "gpu-server:50051"
    }
  ],
  "connections": [
    {
      "from": "input_0",
      "to": "transform_1"
    },
    {
      "from": "transform_1",
      "to": "whisper_2"
    }
  ]
}"#;

    // Parse the manifest
    let manifest = parse(manifest_json).expect("Failed to parse manifest");

    // Validate basic structure
    assert_eq!(manifest.version, "v1");
    assert_eq!(manifest.metadata.name, "test-pipeline");
    assert_eq!(manifest.nodes.len(), 3);
    assert_eq!(manifest.connections.len(), 2);

    // Validate it passes validation
    validate(&manifest).expect("Manifest validation failed");
}

#[test]
fn test_parse_manifest_with_capabilities() {
    let manifest_json = r#"{
  "version": "v1",
  "metadata": {
    "name": "ml-pipeline"
  },
  "nodes": [
    {
      "id": "gpu_node_0",
      "node_type": "TransformersPipelineNode",
      "params": {
        "task": "text-generation",
        "model": "gpt2"
      },
      "capabilities": {
        "gpu": {
          "type": "cuda",
          "min_memory_gb": 4.0,
          "required": false
        },
        "memory_gb": 6.0
      }
    }
  ],
  "connections": []
}"#;

    let manifest = parse(manifest_json).expect("Failed to parse");
    validate(&manifest).expect("Failed to validate");

    // Check GPU capability parsing
    let node = &manifest.nodes[0];
    assert!(node.capabilities.is_some());

    let caps = node.capabilities.as_ref().unwrap();
    assert!(caps.gpu.is_some());

    let gpu = caps.gpu.as_ref().unwrap();
    assert_eq!(gpu.gpu_type, "cuda");
    assert_eq!(gpu.min_memory_gb, Some(4.0));
    assert_eq!(gpu.required, false);

    assert_eq!(caps.memory_gb, Some(6.0));
}

#[test]
fn test_parse_manifest_with_remote_host() {
    let manifest_json = r#"{
  "version": "v1",
  "metadata": {
    "name": "remote-pipeline"
  },
  "nodes": [
    {
      "id": "remote_node_0",
      "node_type": "RemoteExecutionNode",
      "params": {
        "node_to_execute": "CalculatorNode"
      },
      "host": "localhost:50051"
    }
  ],
  "connections": []
}"#;

    let manifest = parse(manifest_json).expect("Failed to parse");
    validate(&manifest).expect("Failed to validate");

    let node = &manifest.nodes[0];
    assert_eq!(node.host, Some("localhost:50051".to_string()));
}

#[test]
fn test_reject_invalid_version() {
    let manifest_json = r#"{
  "version": "v2",
  "metadata": {"name": "test"},
  "nodes": [{"id": "n1", "node_type": "Test", "params": {}}],
  "connections": []
}"#;

    let manifest = parse(manifest_json).expect("Failed to parse");
    let result = validate(&manifest);

    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Unsupported manifest version"));
}

#[test]
fn test_reject_empty_nodes() {
    let manifest_json = r#"{
  "version": "v1",
  "metadata": {"name": "test"},
  "nodes": [],
  "connections": []
}"#;

    let manifest = parse(manifest_json).expect("Failed to parse");
    let result = validate(&manifest);

    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("at least one node"));
}

#[test]
fn test_reject_invalid_connection() {
    let manifest_json = r#"{
  "version": "v1",
  "metadata": {"name": "test"},
  "nodes": [
    {"id": "n1", "node_type": "Test", "params": {}}
  ],
  "connections": [
    {"from": "n1", "to": "invalid_node"}
  ]
}"#;

    let manifest = parse(manifest_json).expect("Failed to parse");
    let result = validate(&manifest);

    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("unknown"));
}
