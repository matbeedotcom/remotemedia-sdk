//! License validation and activation
//!
//! This module handles license file parsing, Ed25519 signature verification,
//! and persistence. License files are JSON documents containing:
//! - Customer and license identification
//! - Expiry dates
//! - Feature entitlements
//! - Ed25519 signature over the canonicalized payload

use anyhow::Result;
use base64::{engine::general_purpose::STANDARD as BASE64, Engine};
use chrono::{DateTime, Utc};
use ed25519_dalek::{Signature, VerifyingKey};
use serde::{Deserialize, Serialize};
use serde_json_canonicalizer::to_vec as canonicalize;
use std::collections::BTreeMap;
use std::path::{Path, PathBuf};
use thiserror::Error;
use tracing::{debug, info, warn};

// ============================================================================
// Embedded Public Key (T008)
// ============================================================================

/// Default Ed25519 public key for license verification.
/// Used when no key is embedded at build time (development/filesystem licenses).
/// Generated by tools/license-signer and committed to the repo.
const DEFAULT_PUBLIC_KEY: [u8; 32] = [
    0xea, 0xcf, 0x23, 0x7c, 0xca, 0x67, 0xbc, 0x95,
    0x69, 0x16, 0x19, 0xb4, 0x99, 0x81, 0x9f, 0xc5,
    0x35, 0xd1, 0xa4, 0xe2, 0x1f, 0x12, 0x57, 0x59,
    0x87, 0xf6, 0xb4, 0x04, 0x3d, 0xaa, 0x69, 0xaa,
];

/// Get the public key to use for license verification.
/// Uses embedded key from build if available, otherwise falls back to default.
fn get_public_key() -> [u8; 32] {
    crate::EMBEDDED_PUBLIC_KEY.unwrap_or(DEFAULT_PUBLIC_KEY)
}

// ============================================================================
// Error Types (T007)
// ============================================================================

/// License validation errors
#[derive(Error, Debug)]
pub enum LicenseError {
    #[error("Invalid license file format: {0}")]
    InvalidFormat(String),

    #[error("Invalid license signature")]
    InvalidSignature,

    #[error("License has expired on {0}")]
    Expired(String),

    #[error("License not yet valid until {0}")]
    NotYetValid(String),

    #[error("Your eval license doesn't include {0}")]
    #[allow(dead_code)] // Used when entitlement gating is enabled
    MissingEntitlement(String),

    #[error("Failed to read license file: {0}")]
    ReadError(String),

    #[error("Failed to save license file: {0}")]
    SaveError(String),
}

// ============================================================================
// Entitlements (T005)
// ============================================================================

/// Feature entitlements granted by the license.
/// Controls which ingest schemes, features, and session limits apply.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct Entitlements {
    /// Permitted URI schemes for ingestion (e.g., "file", "udp", "srt", "rtmp")
    pub allow_ingest_schemes: Vec<String>,

    /// Whether video processing is enabled
    pub allow_video: bool,

    /// Maximum session duration in seconds (None = unlimited)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_session_duration_secs: Option<u64>,
}

impl Default for Entitlements {
    fn default() -> Self {
        Self {
            allow_ingest_schemes: vec![
                "file".to_string(),
                "udp".to_string(),
                "srt".to_string(),
                "rtmp".to_string(),
            ],
            allow_video: true,
            max_session_duration_secs: None,
        }
    }
}

#[allow(dead_code)] // Used by main.rs for entitlement gating
impl Entitlements {
    /// Check if a given ingest scheme is allowed
    pub fn check_ingest_scheme(&self, scheme: &str) -> Result<(), LicenseError> {
        let normalized = scheme.to_lowercase();
        if self.allow_ingest_schemes.iter().any(|s| s.to_lowercase() == normalized) {
            Ok(())
        } else {
            Err(LicenseError::MissingEntitlement(format!(
                "{} ingest",
                scheme.to_uppercase()
            )))
        }
    }

    /// Check if video processing is allowed
    pub fn check_video_allowed(&self) -> Result<(), LicenseError> {
        if self.allow_video {
            Ok(())
        } else {
            Err(LicenseError::MissingEntitlement("video processing".to_string()))
        }
    }

    /// Get the session duration limit if set
    pub fn get_session_duration(&self) -> Option<std::time::Duration> {
        self.max_session_duration_secs
            .map(std::time::Duration::from_secs)
    }
}

// ============================================================================
// License Payload (for signing/verification)
// ============================================================================

/// The signable portion of the license (excludes signature field).
/// Used for canonicalization before signature verification.
#[derive(Debug, Clone, Serialize, Deserialize)]
struct LicensePayload {
    version: u32,
    customer_id: String,
    license_id: String,
    issued_at: String,
    expires_at: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    not_before: Option<String>,
    entitlements: BTreeMap<String, serde_json::Value>,
    watermark: String,
}

// ============================================================================
// License (T004)
// ============================================================================

/// License structure for eval license validation.
/// Uses Ed25519 signatures for offline cryptographic verification.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct License {
    /// License format version (currently 1)
    pub version: u32,

    /// Customer identifier (UUID)
    pub customer_id: String,

    /// Unique license identifier (UUID)
    pub license_id: String,

    /// When the license was issued (ISO 8601)
    pub issued_at: DateTime<Utc>,

    /// When the license expires (ISO 8601)
    pub expires_at: DateTime<Utc>,

    /// Earliest valid activation time (ISO 8601, optional)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub not_before: Option<DateTime<Utc>>,

    /// Feature entitlements
    pub entitlements: Entitlements,

    /// Watermark text embedded in outputs
    pub watermark: String,

    /// Ed25519 signature (base64 encoded, 64 bytes)
    pub signature: String,
}

impl License {
    /// Load a license from a JSON file
    pub fn from_file(path: &Path) -> Result<Self, LicenseError> {
        debug!("Loading license from: {:?}", path);

        let contents = std::fs::read_to_string(path)
            .map_err(|e| LicenseError::ReadError(e.to_string()))?;

        Self::from_json(&contents)
    }

    /// Parse a license from a JSON string
    pub fn from_json(json: &str) -> Result<Self, LicenseError> {
        let license: License = serde_json::from_str(json)
            .map_err(|e| LicenseError::InvalidFormat(e.to_string()))?;

        // Validate required fields
        if license.version == 0 {
            return Err(LicenseError::InvalidFormat("version must be > 0".to_string()));
        }
        if license.customer_id.is_empty() {
            return Err(LicenseError::InvalidFormat("customer_id is required".to_string()));
        }
        if license.license_id.is_empty() {
            return Err(LicenseError::InvalidFormat("license_id is required".to_string()));
        }
        if license.watermark.is_empty() {
            return Err(LicenseError::InvalidFormat("watermark is required".to_string()));
        }
        if license.signature.is_empty() {
            return Err(LicenseError::InvalidFormat("signature is required".to_string()));
        }

        Ok(license)
    }

    /// Validate the license: signature, expiry, and not_before checks
    pub fn validate(&self) -> Result<(), LicenseError> {
        // Check signature first
        self.verify_signature()?;

        // Check expiry
        let now = Utc::now();
        if now > self.expires_at {
            warn!(
                license_id = %self.license_id,
                expires_at = %self.expires_at,
                "License has expired"
            );
            return Err(LicenseError::Expired(
                self.expires_at.format("%Y-%m-%d").to_string(),
            ));
        }

        // Check not_before
        if let Some(not_before) = self.not_before {
            if now < not_before {
                warn!(
                    license_id = %self.license_id,
                    not_before = %not_before,
                    "License not yet valid"
                );
                return Err(LicenseError::NotYetValid(
                    not_before.format("%Y-%m-%d").to_string(),
                ));
            }
        }

        info!(
            license_id = %self.license_id,
            customer_id = %self.customer_id,
            expires_at = %self.expires_at,
            "License validated successfully"
        );
        Ok(())
    }

    /// Check if the license has expired
    pub fn is_expired(&self) -> bool {
        Utc::now() > self.expires_at
    }

    /// Get display-friendly status string
    pub fn status_string(&self) -> &'static str {
        if self.is_expired() {
            "EXPIRED"
        } else if let Some(not_before) = self.not_before {
            if Utc::now() < not_before {
                "NOT YET VALID"
            } else {
                "VALID"
            }
        } else {
            "VALID"
        }
    }

    /// Display license status to stdout
    pub fn display_status(&self) {
        let status = self.status_string();
        let status_marker = if status == "VALID" { "✓" } else { "✗" };

        println!();
        println!("License Status: {} {}", status_marker, status);
        println!();
        println!("  Customer ID:  {}", self.customer_id);
        println!("  License ID:   {}", self.license_id);
        println!("  Watermark:    {}", self.watermark);
        println!("  Issued:       {}", self.issued_at.format("%Y-%m-%d"));
        println!("  Expires:      {}", self.expires_at.format("%Y-%m-%d"));
        if let Some(not_before) = self.not_before {
            println!("  Valid from:   {}", not_before.format("%Y-%m-%d"));
        }
        println!();
        println!("  Entitlements:");
        println!(
            "    Ingest schemes: {}",
            self.entitlements.allow_ingest_schemes.join(", ")
        );
        println!("    Video enabled:  {}", self.entitlements.allow_video);
        if let Some(max_duration) = self.entitlements.max_session_duration_secs {
            println!("    Max session:    {} seconds", max_duration);
        } else {
            println!("    Max session:    unlimited");
        }
        println!();
    }

    // ========================================================================
    // Signature Verification (T010)
    // ========================================================================

    /// Verify the Ed25519 signature over the canonicalized payload.
    /// Uses verify_strict() to reject weak key forgery attacks.
    fn verify_signature(&self) -> Result<(), LicenseError> {
        debug!("Verifying license signature for license_id={}", self.license_id);

        // Build the payload for verification (same structure as during signing)
        let payload = self.build_payload_for_signing();

        // Canonicalize the payload (RFC 8785)
        let canonical_bytes = canonicalize_for_signing(&payload)?;

        // Decode the signature from base64
        let sig_bytes = BASE64
            .decode(&self.signature)
            .map_err(|e| {
                warn!("Failed to decode signature base64: {}", e);
                LicenseError::InvalidSignature
            })?;

        if sig_bytes.len() != 64 {
            warn!(
                "Signature has wrong length: expected 64, got {}",
                sig_bytes.len()
            );
            return Err(LicenseError::InvalidSignature);
        }

        let signature = Signature::from_bytes(
            sig_bytes
                .as_slice()
                .try_into()
                .map_err(|_| LicenseError::InvalidSignature)?,
        );

        // Get the public key (embedded at build time or default)
        let public_key = get_public_key();
        let verifying_key = VerifyingKey::from_bytes(&public_key).map_err(|e| {
            warn!("Invalid public key: {}", e);
            LicenseError::InvalidSignature
        })?;

        // Verify using strict mode (rejects weak key forgery attacks)
        verifying_key
            .verify_strict(&canonical_bytes, &signature)
            .map_err(|e| {
                warn!("Signature verification failed: {}", e);
                LicenseError::InvalidSignature
            })?;

        debug!("Signature verified successfully");
        Ok(())
    }

    /// Build the payload structure used for signing/verification.
    /// Excludes the signature field.
    fn build_payload_for_signing(&self) -> LicensePayload {
        // Convert entitlements to a BTreeMap for deterministic ordering
        let mut entitlements_map = BTreeMap::new();
        entitlements_map.insert(
            "allow_ingest_schemes".to_string(),
            serde_json::json!(self.entitlements.allow_ingest_schemes),
        );
        entitlements_map.insert(
            "allow_video".to_string(),
            serde_json::json!(self.entitlements.allow_video),
        );
        if let Some(max_duration) = self.entitlements.max_session_duration_secs {
            entitlements_map.insert(
                "max_session_duration_secs".to_string(),
                serde_json::json!(max_duration),
            );
        }

        LicensePayload {
            version: self.version,
            customer_id: self.customer_id.clone(),
            license_id: self.license_id.clone(),
            issued_at: self.issued_at.to_rfc3339(),
            expires_at: self.expires_at.to_rfc3339(),
            not_before: self.not_before.map(|dt| dt.to_rfc3339()),
            entitlements: entitlements_map,
            watermark: self.watermark.clone(),
        }
    }
}

// ============================================================================
// Canonicalization (T009)
// ============================================================================

/// Canonicalize a payload for signing using RFC 8785 (JSON Canonicalization Scheme).
/// Ensures deterministic byte representation across platforms.
fn canonicalize_for_signing<T: Serialize>(payload: &T) -> Result<Vec<u8>, LicenseError> {
    canonicalize(payload).map_err(|e| {
        LicenseError::InvalidFormat(format!("Failed to canonicalize: {}", e))
    })
}

// ============================================================================
// License Persistence (T020, T021)
// ============================================================================

/// Get the platform-specific path for the license file.
/// - Linux: ~/.config/remotemedia/license.json
/// - macOS: ~/Library/Application Support/remotemedia/license.json
/// - Windows: %APPDATA%\remotemedia\license.json
pub fn get_license_path() -> Option<PathBuf> {
    dirs::config_dir().map(|p| p.join("remotemedia").join("license.json"))
}

/// Try to load a license embedded at build time.
/// Returns None if no license was embedded or if it's invalid.
pub fn load_embedded_license() -> Option<License> {
    // EMBEDDED_LICENSE_JSON is defined in the generated embedded_license.rs
    let json = crate::EMBEDDED_LICENSE_JSON?;

    match License::from_json(json) {
        Ok(license) => {
            match license.validate() {
                Ok(()) => {
                    debug!("Using embedded license: {}", license.license_id);
                    Some(license)
                }
                Err(e) => {
                    warn!("Embedded license validation failed: {}", e);
                    None
                }
            }
        }
        Err(e) => {
            warn!("Failed to parse embedded license: {}", e);
            None
        }
    }
}

/// Check if a license is embedded in this binary
pub fn has_embedded_license() -> bool {
    crate::EMBEDDED_LICENSE_JSON.is_some()
}

/// Load license from embedded, then default config location
/// Priority: 1. Embedded license, 2. Filesystem license
pub fn load_license() -> Result<License, LicenseError> {
    // First try embedded license
    if let Some(license) = load_embedded_license() {
        return Ok(license);
    }

    // Fall back to filesystem
    let path = get_license_path()
        .ok_or_else(|| LicenseError::ReadError("No config directory".to_string()))?;
    load_license_from_path(&path)
}

/// Load license from a specific path
pub fn load_license_from_path(path: &Path) -> Result<License, LicenseError> {
    if !path.exists() {
        return Err(LicenseError::ReadError(format!(
            "License file not found: {}",
            path.display()
        )));
    }

    let license = License::from_file(path)?;
    license.validate()?;
    Ok(license)
}

/// Save license to the default config location
pub fn save_license(license: &License) -> Result<(), LicenseError> {
    let path = get_license_path()
        .ok_or_else(|| LicenseError::SaveError("No config directory".to_string()))?;

    save_license_to_path(license, &path)
}

/// Save license to a specific path
pub fn save_license_to_path(license: &License, path: &Path) -> Result<(), LicenseError> {
    // Ensure parent directory exists
    if let Some(parent) = path.parent() {
        std::fs::create_dir_all(parent)
            .map_err(|e| LicenseError::SaveError(e.to_string()))?;
    }

    let contents = serde_json::to_string_pretty(license)
        .map_err(|e| LicenseError::SaveError(e.to_string()))?;

    std::fs::write(path, contents)
        .map_err(|e| LicenseError::SaveError(e.to_string()))?;

    info!("License saved to: {:?}", path);
    Ok(())
}

// ============================================================================
// CLI Commands (T022, T023)
// ============================================================================

/// Activate a license from a file path (T023)
pub fn activate_license_from_file(source_path: &Path) -> Result<License, LicenseError> {
    info!("Activating license from: {:?}", source_path);

    // Load and validate the source license
    let license = License::from_file(source_path)?;
    license.validate()?;

    // Save to config directory
    save_license(&license)?;

    info!(
        license_id = %license.license_id,
        customer_id = %license.customer_id,
        "License activated successfully"
    );
    Ok(license)
}

/// Handle the activate subcommand (T023)
pub fn activate_license_command(file_path: &str) -> Result<()> {
    let path = Path::new(file_path);

    println!("Activating license from: {}...", file_path);

    match activate_license_from_file(path) {
        Ok(license) => {
            println!();
            println!("License activated successfully!");
            println!();
            license.display_status();
            println!("You can now run remotemedia-demo without demo time limits.");
            Ok(())
        }
        Err(e) => {
            eprintln!();
            eprintln!("License activation failed: {}", e);
            eprintln!();
            match &e {
                LicenseError::InvalidSignature => {
                    eprintln!("The license file has an invalid signature.");
                    eprintln!("Please ensure you have a valid license file from RemoteMedia.");
                }
                LicenseError::Expired(_) => {
                    eprintln!("Your license has expired. Please contact support for renewal.");
                }
                LicenseError::NotYetValid(_) => {
                    eprintln!("Your license is not yet active. Please try again later.");
                }
                _ => {
                    eprintln!("Please check the license file and try again.");
                }
            }
            eprintln!();
            eprintln!("For help, visit: https://remotemedia.dev/support");
            Err(anyhow::anyhow!("License activation failed"))
        }
    }
}

/// Handle the --license-status flag (T030)
/// If license_file is provided, use that instead of the installed license.
pub fn show_license_status_command(license_file: Option<&str>) -> Result<()> {
    // Try to load from specified file or installed location
    let license_result = if let Some(path) = license_file {
        let path = Path::new(path);
        License::from_file(path).and_then(|l| {
            l.validate()?;
            Ok(l)
        })
    } else {
        load_license()
    };

    match license_result {
        Ok(license) => {
            license.display_status();
            Ok(())
        }
        Err(LicenseError::ReadError(msg)) if msg.contains("not found") => {
            println!();
            println!("No license activated");
            println!();
            println!("To activate a license, run:");
            println!("  remotemedia-demo activate --file <license.json>");
            println!();
            println!("To obtain a license, visit:");
            println!("  https://remotemedia.dev/license");
            println!();
            Ok(())
        }
        Err(e) => {
            eprintln!("Failed to load license: {}", e);
            Err(anyhow::anyhow!("Failed to load license"))
        }
    }
}

// ============================================================================
// Watermark Support (T006 is in events.rs, but we provide helpers here)
// ============================================================================

/// Create a watermark from a valid license
#[allow(dead_code)] // Called by main.rs when integrating watermarks
pub fn create_watermark_from_license(license: &License) -> Watermark {
    Watermark {
        demo: true,
        customer_id: Some(license.customer_id.clone()),
        license_id: Some(license.license_id.clone()),
        watermark: license.watermark.clone(),
        expires_at: Some(license.expires_at.to_rfc3339()),
    }
}

/// Create a demo mode watermark (no license)
#[allow(dead_code)] // Called by main.rs when no license is active
pub fn create_demo_watermark() -> Watermark {
    Watermark {
        demo: true,
        customer_id: None,
        license_id: None,
        watermark: "DEMO-UNLICENSED".to_string(),
        expires_at: None,
    }
}

/// Watermark metadata block embedded in all outputs
#[allow(dead_code)] // Used by main.rs when integrating watermarks
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct Watermark {
    /// Always true for demo/eval mode
    pub demo: bool,
    /// Customer identifier (None if unlicensed)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub customer_id: Option<String>,
    /// License identifier (None if unlicensed)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub license_id: Option<String>,
    /// Watermark text
    pub watermark: String,
    /// License expiration (None if unlicensed)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expires_at: Option<String>,
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    // T011: Valid signature verification
    #[test]
    fn test_valid_license_structure() {
        let json = r#"{
            "version": 1,
            "customer_id": "c9f4e3d2-b1a0-4f8e-9d6c-5b4a3e2f1d0c",
            "license_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
            "issued_at": "2026-01-01T00:00:00Z",
            "expires_at": "2027-01-01T00:00:00Z",
            "entitlements": {
                "allow_ingest_schemes": ["file", "udp", "srt"],
                "allow_video": true,
                "max_session_duration_secs": 3600
            },
            "watermark": "EVAL-TEST",
            "signature": "dGVzdCBzaWduYXR1cmUgdGhhdCBpcyA2NCBieXRlcyBsb25nIHdoZW4gZGVjb2RlZCBmcm9tIGJhc2U2NA=="
        }"#;

        let license = License::from_json(json).unwrap();
        assert_eq!(license.version, 1);
        assert_eq!(license.customer_id, "c9f4e3d2-b1a0-4f8e-9d6c-5b4a3e2f1d0c");
        assert_eq!(license.entitlements.allow_ingest_schemes.len(), 3);
        assert!(license.entitlements.allow_video);
        assert_eq!(license.entitlements.max_session_duration_secs, Some(3600));
    }

    // T012: Invalid signature rejection
    #[test]
    fn test_invalid_signature_format() {
        let json = r#"{
            "version": 1,
            "customer_id": "test",
            "license_id": "test",
            "issued_at": "2026-01-01T00:00:00Z",
            "expires_at": "2027-01-01T00:00:00Z",
            "entitlements": {
                "allow_ingest_schemes": ["file"],
                "allow_video": true
            },
            "watermark": "TEST",
            "signature": "invalid-not-base64!@#$"
        }"#;

        let license = License::from_json(json).unwrap();
        // Signature verification should fail
        let result = license.verify_signature();
        assert!(matches!(result, Err(LicenseError::InvalidSignature)));
    }

    // T013: Expired license rejection
    #[test]
    fn test_expired_license() {
        let mut license = create_test_license();
        license.expires_at = Utc::now() - chrono::Duration::days(1);

        assert!(license.is_expired());

        // Validation should fail with Expired error (after signature check)
        // Note: In tests, signature verification will fail first with placeholder key
    }

    // T014: not_before future date rejection
    #[test]
    fn test_not_yet_valid_license() {
        let license = License {
            not_before: Some(Utc::now() + chrono::Duration::days(30)),
            ..create_test_license()
        };

        assert_eq!(license.status_string(), "NOT YET VALID");
    }

    // T032: Ingest scheme entitlement check (allowed)
    #[test]
    fn test_ingest_scheme_allowed() {
        let entitlements = Entitlements {
            allow_ingest_schemes: vec!["file".to_string(), "srt".to_string()],
            allow_video: true,
            max_session_duration_secs: None,
        };

        assert!(entitlements.check_ingest_scheme("file").is_ok());
        assert!(entitlements.check_ingest_scheme("srt").is_ok());
        assert!(entitlements.check_ingest_scheme("FILE").is_ok()); // Case insensitive
    }

    // T033: Ingest scheme entitlement check (disallowed)
    #[test]
    fn test_ingest_scheme_disallowed() {
        let entitlements = Entitlements {
            allow_ingest_schemes: vec!["file".to_string()],
            allow_video: true,
            max_session_duration_secs: None,
        };

        let result = entitlements.check_ingest_scheme("rtmp");
        assert!(matches!(result, Err(LicenseError::MissingEntitlement(_))));
    }

    // T034: Video entitlement check
    #[test]
    fn test_video_entitlement() {
        let allowed = Entitlements {
            allow_ingest_schemes: vec![],
            allow_video: true,
            max_session_duration_secs: None,
        };
        assert!(allowed.check_video_allowed().is_ok());

        let disallowed = Entitlements {
            allow_ingest_schemes: vec![],
            allow_video: false,
            max_session_duration_secs: None,
        };
        assert!(matches!(
            disallowed.check_video_allowed(),
            Err(LicenseError::MissingEntitlement(_))
        ));
    }

    // T035: Session duration entitlement
    #[test]
    fn test_session_duration() {
        let limited = Entitlements {
            allow_ingest_schemes: vec![],
            allow_video: true,
            max_session_duration_secs: Some(900),
        };
        assert_eq!(
            limited.get_session_duration(),
            Some(std::time::Duration::from_secs(900))
        );

        let unlimited = Entitlements::default();
        assert!(unlimited.get_session_duration().is_none());
    }

    // T025: License status display (valid)
    #[test]
    fn test_license_status_valid() {
        let license = create_test_license();
        assert_eq!(license.status_string(), "VALID");
    }

    // T027: License status display (expired)
    #[test]
    fn test_license_status_expired() {
        let mut license = create_test_license();
        license.expires_at = Utc::now() - chrono::Duration::days(1);
        assert_eq!(license.status_string(), "EXPIRED");
    }

    // T044: Watermark serialization
    #[test]
    fn test_watermark_serialization() {
        let watermark = Watermark {
            demo: true,
            customer_id: Some("customer-123".to_string()),
            license_id: Some("license-456".to_string()),
            watermark: "EVAL-TEST".to_string(),
            expires_at: Some("2027-01-01T00:00:00Z".to_string()),
        };

        let json = serde_json::to_string(&watermark).unwrap();
        assert!(json.contains("\"demo\":true"));
        assert!(json.contains("\"customer_id\":\"customer-123\""));
        assert!(json.contains("\"watermark\":\"EVAL-TEST\""));
    }

    // T045: Demo mode watermark
    #[test]
    fn test_demo_watermark() {
        let watermark = create_demo_watermark();
        assert!(watermark.demo);
        assert!(watermark.customer_id.is_none());
        assert!(watermark.license_id.is_none());
        assert_eq!(watermark.watermark, "DEMO-UNLICENSED");
        assert!(watermark.expires_at.is_none());
    }

    // T046: Licensed watermark
    #[test]
    fn test_licensed_watermark() {
        let license = create_test_license();
        let watermark = create_watermark_from_license(&license);

        assert!(watermark.demo);
        assert_eq!(watermark.customer_id, Some(license.customer_id));
        assert_eq!(watermark.license_id, Some(license.license_id));
        assert_eq!(watermark.watermark, license.watermark);
        assert!(watermark.expires_at.is_some());
    }

    // Helper to create a test license
    fn create_test_license() -> License {
        License {
            version: 1,
            customer_id: "test-customer-id".to_string(),
            license_id: "test-license-id".to_string(),
            issued_at: Utc::now() - chrono::Duration::days(30),
            expires_at: Utc::now() + chrono::Duration::days(180),
            not_before: None,
            entitlements: Entitlements::default(),
            watermark: "EVAL-TEST".to_string(),
            signature: "dGVzdA==".to_string(), // "test" in base64
        }
    }

    #[test]
    fn test_entitlements_default() {
        let entitlements = Entitlements::default();
        assert!(entitlements.allow_ingest_schemes.contains(&"file".to_string()));
        assert!(entitlements.allow_ingest_schemes.contains(&"srt".to_string()));
        assert!(entitlements.allow_video);
        assert!(entitlements.max_session_duration_secs.is_none());
    }

    #[test]
    fn test_license_from_json_missing_fields() {
        // Missing signature
        let json = r#"{
            "version": 1,
            "customer_id": "test",
            "license_id": "test",
            "issued_at": "2026-01-01T00:00:00Z",
            "expires_at": "2027-01-01T00:00:00Z",
            "entitlements": { "allow_ingest_schemes": [], "allow_video": true },
            "watermark": "TEST"
        }"#;

        let result = License::from_json(json);
        assert!(result.is_err());
    }

    #[test]
    fn test_canonicalization() {
        // Test that canonicalization produces consistent output
        let payload1 = LicensePayload {
            version: 1,
            customer_id: "test".to_string(),
            license_id: "test".to_string(),
            issued_at: "2026-01-01T00:00:00Z".to_string(),
            expires_at: "2027-01-01T00:00:00Z".to_string(),
            not_before: None,
            entitlements: BTreeMap::new(),
            watermark: "TEST".to_string(),
        };

        let bytes1 = canonicalize_for_signing(&payload1).unwrap();
        let bytes2 = canonicalize_for_signing(&payload1).unwrap();

        assert_eq!(bytes1, bytes2, "Canonicalization should be deterministic");
    }
}
