<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RemoteMedia WebRTC Demo</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #e8e8e8;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      padding: 20px 0 40px;
    }

    h1 {
      font-size: 2.5rem;
      background: linear-gradient(90deg, #00d9ff, #00ff88);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 10px;
    }

    .subtitle {
      color: #888;
      font-size: 1.1rem;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }

    @media (max-width: 800px) {
      .grid {
        grid-template-columns: 1fr;
      }
    }

    .card {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 20px;
    }

    .card h2 {
      font-size: 1.2rem;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .card h2::before {
      content: '';
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #00ff88;
    }

    .status-indicator {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 20px;
      font-size: 0.9rem;
    }

    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #666;
      transition: background 0.3s;
    }

    .status-dot.connected {
      background: #00ff88;
      box-shadow: 0 0 10px #00ff88;
    }

    .status-dot.connecting {
      background: #ffaa00;
      animation: pulse 1s infinite;
    }

    .status-dot.error {
      background: #ff4444;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .video-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin: 15px 0;
    }

    .video-box {
      background: #000;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      aspect-ratio: 16/9;
    }

    .video-box video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .video-label {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 0.8rem;
    }

    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 15px;
    }

    button {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-primary {
      background: linear-gradient(90deg, #00d9ff, #00ff88);
      color: #000;
      font-weight: 600;
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(0, 217, 255, 0.3);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
    }

    .btn-secondary:hover:not(:disabled) {
      background: rgba(255, 255, 255, 0.2);
    }

    .btn-danger {
      background: #ff4444;
      color: #fff;
    }

    .btn-danger:hover:not(:disabled) {
      background: #ff6666;
    }

    .log-container {
      background: #0a0a0f;
      border-radius: 8px;
      padding: 15px;
      max-height: 300px;
      overflow-y: auto;
      font-family: 'Fira Code', 'Monaco', monospace;
      font-size: 0.85rem;
    }

    .log-entry {
      padding: 4px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .log-entry:last-child {
      border-bottom: none;
    }

    .log-time {
      color: #666;
      margin-right: 10px;
    }

    .log-info { color: #00d9ff; }
    .log-success { color: #00ff88; }
    .log-warning { color: #ffaa00; }
    .log-error { color: #ff4444; }

    .peers-list {
      list-style: none;
    }

    .peers-list li {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 6px;
      margin-bottom: 8px;
    }

    .peer-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: linear-gradient(135deg, #00d9ff, #00ff88);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
    }

    .peer-info {
      flex: 1;
    }

    .peer-id {
      font-weight: 500;
    }

    .peer-capabilities {
      font-size: 0.8rem;
      color: #888;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
    }

    .stat-box {
      text-align: center;
      padding: 15px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 8px;
    }

    .stat-value {
      font-size: 1.8rem;
      font-weight: bold;
      background: linear-gradient(90deg, #00d9ff, #00ff88);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .stat-label {
      font-size: 0.85rem;
      color: #888;
      margin-top: 5px;
    }

    .empty-state {
      text-align: center;
      padding: 30px;
      color: #666;
    }

    .config-info {
      font-size: 0.85rem;
      color: #888;
      margin-top: 10px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 6px;
    }

    .config-info code {
      color: #00d9ff;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>RemoteMedia WebRTC Demo</h1>
      <p class="subtitle">Real-time media streaming with Rust-powered FFI bindings</p>
      <p class="subtitle" style="margin-top: 5px; font-size: 0.9rem;">Using JSON-RPC 2.0 signaling protocol</p>
    </header>

    <div class="grid">
      <!-- Connection Panel -->
      <div class="card">
        <h2>Connection</h2>
        <div style="margin-bottom: 15px;">
          <div class="status-indicator">
            <div class="status-dot" id="ws-status"></div>
            <span id="ws-status-text">Disconnected</span>
          </div>
          <div class="status-indicator" style="margin-left: 10px;">
            <div class="status-dot" id="rtc-status"></div>
            <span id="rtc-status-text">Not Connected</span>
          </div>
        </div>

        <div class="controls">
          <button class="btn-primary" id="btn-connect" onclick="connect()">
            Connect to Signaling
          </button>
          <button class="btn-secondary" id="btn-start-media" onclick="startMedia()" disabled>
            Start Media
          </button>
          <button class="btn-danger" id="btn-disconnect" onclick="disconnect()" disabled>
            Disconnect
          </button>
        </div>

        <div class="config-info">
          Signaling: <code id="signaling-url">{{SIGNALING_URL}}</code>
        </div>
      </div>

      <!-- Stats Panel -->
      <div class="card">
        <h2>Statistics</h2>
        <div class="stats-grid">
          <div class="stat-box">
            <div class="stat-value" id="stat-peers">0</div>
            <div class="stat-label">Connected Peers</div>
          </div>
          <div class="stat-box">
            <div class="stat-value" id="stat-sessions">0</div>
            <div class="stat-label">Active Sessions</div>
          </div>
          <div class="stat-box">
            <div class="stat-value" id="stat-latency">--</div>
            <div class="stat-label">Latency (ms)</div>
          </div>
        </div>
      </div>
    </div>

    <div class="grid">
      <!-- Video Panel -->
      <div class="card">
        <h2>Media Streams</h2>
        <div class="video-container">
          <div class="video-box">
            <video id="local-video" autoplay muted playsinline></video>
            <div class="video-label">Local</div>
          </div>
          <div class="video-box">
            <video id="remote-video" autoplay playsinline></video>
            <div class="video-label">Remote</div>
          </div>
        </div>
        <div class="controls">
          <button class="btn-secondary" id="btn-toggle-audio" onclick="toggleAudio()" disabled>
            Mute Audio
          </button>
          <button class="btn-secondary" id="btn-toggle-video" onclick="toggleVideo()" disabled>
            Disable Video
          </button>
        </div>
      </div>

      <!-- Peers Panel -->
      <div class="card">
        <h2>Connected Peers</h2>
        <ul class="peers-list" id="peers-list">
          <li class="empty-state">No peers connected</li>
        </ul>
      </div>
    </div>

    <!-- Log Panel -->
    <div class="card">
      <h2>Event Log</h2>
      <div class="log-container" id="log-container">
        <div class="log-entry">
          <span class="log-time">--:--:--</span>
          <span class="log-info">Waiting for connection...</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Configuration injected by server
    const SIGNALING_URL = '{{SIGNALING_URL}}';
    const STUN_SERVERS = {{STUN_SERVERS}};

    // State
    let ws = null;
    let pc = null;
    let localStream = null;
    let peerId = null;
    let requestIdCounter = 0;
    let audioEnabled = true;
    let videoEnabled = true;
    const peers = new Map();
    const pendingRequests = new Map();

    // DOM Elements
    const wsStatusDot = document.getElementById('ws-status');
    const wsStatusText = document.getElementById('ws-status-text');
    const rtcStatusDot = document.getElementById('rtc-status');
    const rtcStatusText = document.getElementById('rtc-status-text');
    const btnConnect = document.getElementById('btn-connect');
    const btnStartMedia = document.getElementById('btn-start-media');
    const btnDisconnect = document.getElementById('btn-disconnect');
    const btnToggleAudio = document.getElementById('btn-toggle-audio');
    const btnToggleVideo = document.getElementById('btn-toggle-video');
    const localVideo = document.getElementById('local-video');
    const remoteVideo = document.getElementById('remote-video');
    const peersList = document.getElementById('peers-list');
    const logContainer = document.getElementById('log-container');

    /**
     * Generate unique request ID for JSON-RPC
     */
    function generateRequestId() {
      return `req-${++requestIdCounter}-${Date.now()}`;
    }

    /**
     * Generate unique peer ID
     */
    function generatePeerId() {
      return `peer-${Math.random().toString(36).substr(2, 9)}`;
    }

    /**
     * Add entry to event log
     */
    function log(message, type = 'info') {
      const now = new Date();
      const time = now.toTimeString().split(' ')[0];
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.innerHTML = `<span class="log-time">${time}</span><span class="log-${type}">${message}</span>`;
      logContainer.appendChild(entry);
      logContainer.scrollTop = logContainer.scrollHeight;
    }

    /**
     * Update connection status display
     */
    function updateStatus(type, status, text) {
      const dot = type === 'ws' ? wsStatusDot : rtcStatusDot;
      const textEl = type === 'ws' ? wsStatusText : rtcStatusText;

      dot.className = 'status-dot ' + status;
      textEl.textContent = text;
    }

    /**
     * Update peers list display
     */
    function updatePeersList() {
      if (peers.size === 0) {
        peersList.innerHTML = '<li class="empty-state">No peers connected</li>';
        return;
      }

      peersList.innerHTML = '';
      for (const [id, peer] of peers) {
        const li = document.createElement('li');
        const caps = peer.capabilities || [];

        li.innerHTML = `
          <div class="peer-avatar">${id.charAt(0).toUpperCase()}</div>
          <div class="peer-info">
            <div class="peer-id">${id}</div>
            <div class="peer-capabilities">${caps.join(', ') || 'No capabilities'}</div>
          </div>
        `;
        peersList.appendChild(li);
      }

      document.getElementById('stat-peers').textContent = peers.size;
    }

    /**
     * Send JSON-RPC 2.0 request
     */
    function sendRequest(method, params) {
      const id = generateRequestId();
      const request = {
        jsonrpc: '2.0',
        method,
        params,
        id
      };

      return new Promise((resolve, reject) => {
        pendingRequests.set(id, { resolve, reject });
        ws.send(JSON.stringify(request));
        log(`[RPC] ${method}`, 'info');

        // Timeout after 30 seconds
        setTimeout(() => {
          if (pendingRequests.has(id)) {
            pendingRequests.delete(id);
            reject(new Error('Request timeout'));
          }
        }, 30000);
      });
    }

    /**
     * Send JSON-RPC 2.0 notification (no response expected)
     */
    function sendNotification(method, params) {
      const notification = {
        jsonrpc: '2.0',
        method,
        params
      };
      ws.send(JSON.stringify(notification));
      log(`[RPC] ${method} (notification)`, 'info');
    }

    /**
     * Connect to signaling server
     */
    function connect() {
      if (ws) {
        ws.close();
      }

      peerId = generatePeerId();
      log(`Connecting to signaling server as ${peerId}...`, 'info');
      updateStatus('ws', 'connecting', 'Connecting...');

      ws = new WebSocket(SIGNALING_URL);

      ws.onopen = async () => {
        log('WebSocket connected', 'success');
        updateStatus('ws', 'connected', 'Connected');
        btnConnect.disabled = true;
        btnDisconnect.disabled = false;

        // Announce ourselves to the signaling server
        try {
          const result = await sendRequest('peer.announce', {
            peer_id: peerId,
            capabilities: ['audio', 'video', 'data'],
            user_data: {
              name: 'Browser Client',
              client: 'RemoteMedia Demo'
            }
          });

          log(`Registered with server: ${result.status}`, 'success');
          btnStartMedia.disabled = false;
        } catch (err) {
          log(`Failed to announce: ${err.message}`, 'error');
        }
      };

      ws.onclose = () => {
        log('Disconnected from signaling server', 'warning');
        updateStatus('ws', '', 'Disconnected');
        btnConnect.disabled = false;
        btnStartMedia.disabled = true;
        btnDisconnect.disabled = true;
        peerId = null;
      };

      ws.onerror = (err) => {
        log('WebSocket error', 'error');
        updateStatus('ws', 'error', 'Error');
      };

      ws.onmessage = (event) => {
        const message = JSON.parse(event.data);
        handleSignalingMessage(message);
      };
    }

    /**
     * Handle incoming JSON-RPC 2.0 messages
     */
    function handleSignalingMessage(message) {
      // Handle response to our request
      if (message.id && pendingRequests.has(message.id)) {
        const { resolve, reject } = pendingRequests.get(message.id);
        pendingRequests.delete(message.id);

        if (message.error) {
          reject(new Error(message.error.message));
        } else {
          resolve(message.result);
        }
        return;
      }

      // Handle notification (no id)
      if (message.method) {
        handleNotification(message.method, message.params);
      }
    }

    /**
     * Handle incoming notifications from server
     */
    function handleNotification(method, params) {
      log(`[RPC] Received: ${method}`, 'info');

      switch (method) {
        case 'peer.announced':
          // Another peer joined
          peers.set(params.peer_id, {
            capabilities: params.capabilities,
            user_data: params.user_data
          });
          log(`Peer joined: ${params.peer_id}`, 'success');
          updatePeersList();
          break;

        case 'peer.disconnected':
          // Peer left
          peers.delete(params.from || params.peer_id);
          log(`Peer left: ${params.from || params.peer_id}`, 'warning');
          updatePeersList();
          break;

        case 'peer.offer':
          // Incoming SDP offer
          handleOffer(params);
          break;

        case 'peer.answer':
          // Incoming SDP answer
          handleAnswer(params);
          break;

        case 'peer.ice_candidate':
          // Incoming ICE candidate
          handleIceCandidate(params);
          break;

        default:
          log(`Unknown notification: ${method}`, 'warning');
      }
    }

    /**
     * Start local media and initiate connection
     */
    async function startMedia() {
      try {
        log('Requesting media access...', 'info');

        localStream = await navigator.mediaDevices.getUserMedia({
          audio: true,
          video: true
        });

        localVideo.srcObject = localStream;
        log('Local media started', 'success');

        // Create peer connection
        createPeerConnection();

        // Add tracks to connection
        for (const track of localStream.getTracks()) {
          pc.addTrack(track, localStream);
        }

        // Enable media controls
        btnToggleAudio.disabled = false;
        btnToggleVideo.disabled = false;

        log('Ready to connect. Waiting for peers...', 'info');
      } catch (err) {
        log(`Media error: ${err.message}`, 'error');
      }
    }

    /**
     * Create RTCPeerConnection
     */
    function createPeerConnection() {
      const config = {
        iceServers: STUN_SERVERS.map(url => ({ urls: url }))
      };

      pc = new RTCPeerConnection(config);
      updateStatus('rtc', 'connecting', 'Connecting...');

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          // Send ICE candidate via JSON-RPC notification
          sendNotification('peer.ice_candidate', {
            from: peerId,
            to: 'server', // Server will route to appropriate peer
            candidate: event.candidate.candidate,
            sdp_m_line_index: event.candidate.sdpMLineIndex,
            sdp_mid: event.candidate.sdpMid
          });
        }
      };

      pc.oniceconnectionstatechange = () => {
        log(`ICE state: ${pc.iceConnectionState}`, 'info');

        switch (pc.iceConnectionState) {
          case 'connected':
          case 'completed':
            updateStatus('rtc', 'connected', 'Connected');
            break;
          case 'disconnected':
            updateStatus('rtc', '', 'Disconnected');
            break;
          case 'failed':
            updateStatus('rtc', 'error', 'Failed');
            break;
        }
      };

      pc.ontrack = (event) => {
        log('Remote track received', 'success');
        remoteVideo.srcObject = event.streams[0];
      };

      log('PeerConnection created', 'info');
    }

    /**
     * Create and send SDP offer to a peer
     */
    async function sendOfferToPeer(targetPeerId) {
      if (!pc) createPeerConnection();

      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      const requestId = generateRequestId();

      try {
        await sendRequest('peer.offer', {
          from: peerId,
          to: targetPeerId,
          sdp: offer.sdp,
          can_trickle_ice_candidates: true,
          request_id: requestId
        });
        log(`Offer sent to ${targetPeerId}`, 'info');
      } catch (err) {
        log(`Failed to send offer: ${err.message}`, 'error');
      }
    }

    /**
     * Handle incoming SDP offer
     */
    async function handleOffer(params) {
      log(`Received offer from ${params.from}`, 'info');

      if (!pc) createPeerConnection();

      await pc.setRemoteDescription({ type: 'offer', sdp: params.sdp });
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);

      try {
        await sendRequest('peer.answer', {
          from: peerId,
          to: params.from,
          sdp: answer.sdp,
          can_trickle_ice_candidates: true,
          request_id: params.request_id
        });
        log(`Answer sent to ${params.from}`, 'success');
      } catch (err) {
        log(`Failed to send answer: ${err.message}`, 'error');
      }
    }

    /**
     * Handle incoming SDP answer
     */
    async function handleAnswer(params) {
      log(`Received answer from ${params.from}`, 'info');
      await pc.setRemoteDescription({ type: 'answer', sdp: params.sdp });
      log('Remote description set', 'success');
    }

    /**
     * Handle incoming ICE candidate
     */
    async function handleIceCandidate(params) {
      try {
        const candidate = new RTCIceCandidate({
          candidate: params.candidate,
          sdpMLineIndex: params.sdp_m_line_index,
          sdpMid: params.sdp_mid
        });
        await pc.addIceCandidate(candidate);
      } catch (err) {
        log(`ICE error: ${err.message}`, 'error');
      }
    }

    /**
     * Toggle audio track
     */
    function toggleAudio() {
      if (!localStream) return;

      audioEnabled = !audioEnabled;
      localStream.getAudioTracks().forEach(track => {
        track.enabled = audioEnabled;
      });

      btnToggleAudio.textContent = audioEnabled ? 'Mute Audio' : 'Unmute Audio';
      log(`Audio ${audioEnabled ? 'enabled' : 'disabled'}`, 'info');
    }

    /**
     * Toggle video track
     */
    function toggleVideo() {
      if (!localStream) return;

      videoEnabled = !videoEnabled;
      localStream.getVideoTracks().forEach(track => {
        track.enabled = videoEnabled;
      });

      btnToggleVideo.textContent = videoEnabled ? 'Disable Video' : 'Enable Video';
      log(`Video ${videoEnabled ? 'enabled' : 'disabled'}`, 'info');
    }

    /**
     * Disconnect from server
     */
    function disconnect() {
      // Send disconnect notification
      if (ws && ws.readyState === WebSocket.OPEN && peerId) {
        sendNotification('peer.disconnect', {
          from: peerId,
          reason: 'user_requested'
        });
      }

      if (pc) {
        pc.close();
        pc = null;
      }

      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
        localVideo.srcObject = null;
        remoteVideo.srcObject = null;
      }

      if (ws) {
        ws.close();
        ws = null;
      }

      peers.clear();
      updatePeersList();

      btnToggleAudio.disabled = true;
      btnToggleVideo.disabled = true;
      updateStatus('rtc', '', 'Not Connected');

      log('Disconnected', 'warning');
    }

    /**
     * Fetch server stats periodically
     */
    async function fetchStats() {
      try {
        const [peersRes, sessionsRes] = await Promise.all([
          fetch('/api/peers'),
          fetch('/api/sessions')
        ]);

        if (peersRes.ok) {
          const data = await peersRes.json();
          document.getElementById('stat-peers').textContent = data.peers?.length || 0;
        }

        if (sessionsRes.ok) {
          const data = await sessionsRes.json();
          document.getElementById('stat-sessions').textContent = data.sessions?.length || 0;
        }
      } catch (err) {
        // Ignore errors
      }
    }

    // Fetch stats every 5 seconds
    setInterval(fetchStats, 5000);
    fetchStats();

    log('Ready. Click "Connect to Signaling" to begin.', 'info');
    log(`Using signaling server: ${SIGNALING_URL}`, 'info');
    log(`STUN servers: ${STUN_SERVERS.join(', ')}`, 'info');
  </script>
</body>
</html>
