//! gRPC transport for RemoteMedia pipelines
//!
//! This crate provides a gRPC service implementation that uses
//! `remotemedia-runtime-core` for pipeline execution.
//!
//! # Architecture
//!
//! - **server.rs**: Tonic server setup with middleware (auth, metrics, logging)
//! - **execution.rs**: Unary RPC handler for ExecutePipeline
//! - **streaming.rs**: Bidirectional streaming handler for StreamPipeline
//! - **auth.rs**: API token validation middleware
//! - **limits.rs**: Resource limit enforcement
//! - **metrics.rs**: Prometheus metrics collection
//! - **version.rs**: Protocol version negotiation
//! - **adapters.rs**: RuntimeData â†” Protobuf DataBuffer conversion
//!
//! # Protocol Buffers
//!
//! Generated from `protos/*.proto`:
//! - common.proto: DataBuffer, AudioBuffer, ExecutionMetrics, ErrorResponse
//! - execution.proto: PipelineExecutionService, ExecutePipeline RPC
//! - streaming.proto: StreamingPipelineService, StreamPipeline RPC

#![warn(missing_docs)]
#![warn(clippy::all)]

// Core modules
pub mod auth;
pub mod execution;
pub mod limits;
pub mod metrics;
pub mod server;
pub mod streaming;
pub mod version;
pub mod adapters;

// Session and routing modules
pub mod async_pipeline;
pub mod async_router;
pub mod session_router;

// Multiprocess integration modules (spec 002)
pub mod executor_registry;
pub mod manifest_parser;

// Re-export generated protobuf types
// Generated by tonic-build in build.rs
pub mod generated {
    // Include generated code from build.rs output
    include!("generated/remotemedia.v1.rs");
}

// Re-export key types for convenience
pub use generated::{
    AudioBuffer, AudioFormat, DataBuffer, TextBuffer, BinaryBuffer,
    ErrorResponse, ErrorType, ExecutionMetrics, ExecutionStatus,
    NodeMetrics, NodeResult, NodeStatus, ResourceLimits, VersionInfo,
};

// Service traits
pub use generated::{
    pipeline_execution_service_server::{PipelineExecutionService, PipelineExecutionServiceServer},
    streaming_pipeline_service_server::{
        StreamingPipelineService, StreamingPipelineServiceServer,
    },
};

// Re-export adapter functions
pub use adapters::{
    runtime_data_to_data_buffer,
    data_buffer_to_runtime_data,
    transport_data_to_data_buffer,
    data_buffer_to_transport_data,
};

// Re-export main server types for convenience
pub use server::GrpcServer;
pub use execution::ExecutionServiceImpl;
pub use streaming::StreamingServiceImpl;

/// Error type for gRPC service operations
#[derive(Debug, thiserror::Error)]
pub enum ServiceError {
    /// Validation error
    #[error("Validation error: {0}")]
    Validation(String),

    /// Node execution error
    #[error("Node execution error in {node_id}: {message}")]
    NodeExecution {
        /// Node ID that failed
        node_id: String,
        /// Error message
        message: String
    },

    /// Resource limit exceeded
    #[error("Resource limit exceeded: {0}")]
    ResourceLimit(String),

    /// Internal service error
    #[error("Internal error: {0}")]
    Internal(String),

    /// Core runtime error
    #[error("Runtime error: {0}")]
    Runtime(#[from] remotemedia_runtime_core::Error),

    /// Tonic error
    #[error("gRPC error: {0}")]
    Grpc(#[from] tonic::Status),
}

/// Service configuration
#[derive(Debug, Clone)]
pub struct ServiceConfig {
    /// Bind address for gRPC server
    pub bind_address: String,

    /// Authentication configuration
    pub auth: auth::AuthConfig,

    /// Resource limits
    pub limits: limits::ResourceLimits,

    /// Enable JSON structured logging
    pub json_logging: bool,
}

impl Default for ServiceConfig {
    fn default() -> Self {
        Self {
            bind_address: "0.0.0.0:50051".to_string(),
            auth: auth::AuthConfig::default(),
            limits: limits::ResourceLimits::default(),
            json_logging: true,
        }
    }
}

impl ServiceConfig {
    /// Load configuration from environment variables
    pub fn from_env() -> Self {
        let bind_address = std::env::var("GRPC_BIND_ADDRESS")
            .unwrap_or_else(|_| "0.0.0.0:50051".to_string());

        let require_auth = std::env::var("GRPC_REQUIRE_AUTH")
            .map(|v| v.to_lowercase() == "true")
            .unwrap_or(false);

        let auth_tokens: Vec<String> = std::env::var("GRPC_AUTH_TOKENS")
            .map(|t| t.split(',').map(|s| s.trim().to_string()).collect())
            .unwrap_or_default();

        let max_memory_bytes = std::env::var("GRPC_MAX_MEMORY_MB")
            .ok()
            .and_then(|v| v.parse::<u64>().ok())
            .map(|mb| mb * 1_000_000)
            .unwrap_or(100_000_000);

        let max_timeout_sec = std::env::var("GRPC_MAX_TIMEOUT_SEC")
            .ok()
            .and_then(|v| v.parse::<u64>().ok())
            .unwrap_or(5);

        let json_logging = std::env::var("GRPC_JSON_LOGGING")
            .map(|v| v.to_lowercase() == "true")
            .unwrap_or(true);

        Self {
            bind_address,
            auth: auth::AuthConfig::new(auth_tokens, require_auth),
            limits: limits::ResourceLimits {
                max_memory_bytes,
                max_timeout: std::time::Duration::from_secs(max_timeout_sec),
                ..Default::default()
            },
            json_logging,
        }
    }
}

/// Initialize tracing/logging
pub fn init_tracing(json_logging: bool) {
    use tracing_subscriber::{fmt, EnvFilter, prelude::*};

    let env_filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new("info"));

    if json_logging {
        tracing_subscriber::registry()
            .with(env_filter)
            .with(fmt::layer().json())
            .init();
    } else {
        tracing_subscriber::registry()
            .with(env_filter)
            .with(fmt::layer())
            .init();
    }
}
