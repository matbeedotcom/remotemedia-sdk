// This file is @generated by prost-build.
/// Universal container for any protocol bufferable data type
///
/// Uses protobuf oneof discriminator for type-safe variant selection.
/// Exactly one variant must be set.
///
/// Usage:
/// DataBuffer audio_buf = {
/// audio: { samples: ..., sample_rate: 16000, ... }
/// };
///
/// DataBuffer json_buf = {
/// json: { json_payload: "{"operation": "add"}", ... }
/// };
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataBuffer {
    /// Optional metadata for extensibility
    /// Examples: compression="gzip", encoding="base64", custom_key="value"
    /// Convention: Use lowercase snake_case for keys
    #[prost(map = "string, string", tag = "10")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Data type discriminator (exactly one must be set)
    #[prost(oneof = "data_buffer::DataType", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9")]
    pub data_type: ::core::option::Option<data_buffer::DataType>,
}
/// Nested message and enum types in `DataBuffer`.
pub mod data_buffer {
    /// Data type discriminator (exactly one must be set)
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum DataType {
        #[prost(message, tag = "1")]
        Audio(super::AudioBuffer),
        #[prost(message, tag = "2")]
        Video(super::VideoFrame),
        #[prost(message, tag = "3")]
        Tensor(super::TensorBuffer),
        #[prost(message, tag = "4")]
        Json(super::JsonData),
        #[prost(message, tag = "5")]
        Text(super::TextBuffer),
        #[prost(message, tag = "6")]
        Binary(super::BinaryBuffer),
        /// Spec 007: Control messages for low-latency streaming
        #[prost(message, tag = "7")]
        Control(super::ControlMessage),
        /// NumPy array data with full metadata
        #[prost(message, tag = "8")]
        Numpy(super::NumpyBuffer),
        /// Spec 001: File reference with metadata
        #[prost(message, tag = "9")]
        File(super::FileBuffer),
    }
}
/// Multi-channel audio data with sample rate and format metadata
///
/// Samples are stored in interleaved format for multi-channel audio.
/// For stereo: \[L0, R0, L1, R1, L2, R2, ...\]
///
/// This type is unchanged from Feature 003 to maintain backward compatibility.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AudioBuffer {
    /// Raw audio samples (interleaved, little-endian)
    /// Size = num_samples * channels * format.bytes_per_sample()
    #[prost(bytes = "vec", tag = "1")]
    pub samples: ::prost::alloc::vec::Vec<u8>,
    /// Sample rate in Hz (e.g., 8000, 16000, 44100, 48000)
    #[prost(uint32, tag = "2")]
    pub sample_rate: u32,
    /// Number of channels (1=mono, 2=stereo, 6=5.1 surround)
    #[prost(uint32, tag = "3")]
    pub channels: u32,
    /// Audio sample encoding format
    #[prost(enumeration = "AudioFormat", tag = "4")]
    pub format: i32,
    /// Total number of samples (including all channels)
    /// num_frames = num_samples / channels
    /// duration_seconds = num_frames / sample_rate
    #[prost(uint64, tag = "5")]
    pub num_samples: u64,
}
/// Video frame data with pixel format and dimensions
///
/// Supports common uncompressed pixel formats.
/// Codec support (H.264, H.265, VP8, AV1) added via Spec 012.
///
/// Validation:
/// pixel_data.len() == width * height * format.bytes_per_pixel()
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VideoFrame {
    /// Raw pixel data or encoded bitstream
    /// Layout determined by PixelFormat (raw) or VideoCodec (encoded)
    #[prost(bytes = "vec", tag = "1")]
    pub pixel_data: ::prost::alloc::vec::Vec<u8>,
    /// Frame width in pixels (must be > 0)
    #[prost(uint32, tag = "2")]
    pub width: u32,
    /// Frame height in pixels (must be > 0)
    #[prost(uint32, tag = "3")]
    pub height: u32,
    /// Pixel format (for raw frames) or ENCODED (for compressed)
    #[prost(enumeration = "PixelFormat", tag = "4")]
    pub format: i32,
    /// Frame sequence number for ordering
    #[prost(uint64, tag = "5")]
    pub frame_number: u64,
    /// Timestamp in microseconds (for synchronization)
    #[prost(uint64, tag = "6")]
    pub timestamp_us: u64,
    /// Video codec (Spec 012: Video Codec Support)
    /// UNSPECIFIED for raw frames, or VP8/H264/AV1 for encoded frames
    #[prost(enumeration = "VideoCodec", tag = "7")]
    pub codec: i32,
    /// Keyframe indicator (Spec 012)
    /// True for I-frames (can be decoded independently)
    /// False for P/B-frames (require previous frames)
    #[prost(bool, tag = "8")]
    pub is_keyframe: bool,
}
/// Multi-dimensional tensor data with shape and dtype
///
/// Supports ML use cases: embeddings, image tensors, model inputs/outputs.
/// Data stored in row-major layout by default.
///
/// Validation:
/// data.len() == shape.product() * dtype.bytes_per_element()
///
/// Example (512-dim embedding, F32):
/// TensorBuffer {
/// data: \<2048 bytes>,
/// shape: \[512\],
/// dtype: TENSOR_DTYPE_F32
/// }
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TensorBuffer {
    /// Raw tensor data (row-major layout by default)
    /// Must match calculated size from shape and dtype
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// Shape array (e.g., \[1, 3, 224, 224\] for batch=1, channels=3, 224x224 image)
    /// Empty shape = scalar, \[N\] = vector, \[N, M\] = matrix
    #[prost(uint64, repeated, tag = "2")]
    pub shape: ::prost::alloc::vec::Vec<u64>,
    /// Data type
    #[prost(enumeration = "TensorDtype", tag = "3")]
    pub dtype: i32,
    /// Optional layout hint ("NCHW", "NHWC", "row-major", etc.)
    /// Nodes document expected layout in capabilities
    /// No automatic conversion performed
    #[prost(string, tag = "4")]
    pub layout: ::prost::alloc::string::String,
}
/// JSON payload for structured data, control parameters, and metadata
///
/// Server always parses JSON into serde_json::Value for validation.
/// Nodes work with structured data (easier than string manipulation).
///
/// Example (Calculator request):
/// JsonData {
/// json_payload: "{"operation": "add", "operands": \[10, 20\]}",
/// schema_type: "CalculatorRequest"
/// }
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct JsonData {
    /// JSON payload as string (required, must be valid JSON)
    #[prost(string, tag = "1")]
    pub json_payload: ::prost::alloc::string::String,
    /// Optional schema type hint for validation
    /// Example: "CalculatorRequest", "VADConfig", "DetectionResult"
    /// Nodes can use this to validate structure
    #[prost(string, tag = "2")]
    pub schema_type: ::prost::alloc::string::String,
}
/// UTF-8 text data with optional encoding and language metadata
///
/// Validation: Server validates UTF-8 correctness
///
/// Example:
/// TextBuffer {
/// text_data: "Hello, world!",  // UTF-8 bytes
/// encoding: "utf-8",
/// language: "en"
/// }
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TextBuffer {
    /// Text data as UTF-8 encoded bytes
    /// Server validates UTF-8 correctness
    #[prost(bytes = "vec", tag = "1")]
    pub text_data: ::prost::alloc::vec::Vec<u8>,
    /// Text encoding (default: "utf-8")
    /// Other values: "ascii", "utf-16"
    #[prost(string, tag = "2")]
    pub encoding: ::prost::alloc::string::String,
    /// Optional language code (ISO 639-1, e.g., "en", "es", "zh")
    /// Used for NLP, tokenization, etc.
    #[prost(string, tag = "3")]
    pub language: ::prost::alloc::string::String,
}
/// Raw binary data with mime type hint
///
/// No validation beyond size limits.
/// MIME type accuracy is client responsibility (not validated by protocol).
///
/// Example (PNG image):
/// BinaryBuffer {
/// data: <PNG file bytes>,
/// mime_type: "image/png"
/// }
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BinaryBuffer {
    /// Raw binary data
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// MIME type hint
    /// Examples: "application/octet-stream", "image/png", "application/protobuf"
    /// Not validated by protocol (client responsibility)
    #[prost(string, tag = "2")]
    pub mime_type: ::prost::alloc::string::String,
}
/// NumPy array data with full memory layout metadata
///
/// Preserves all NumPy metadata required for zero-copy reconstruction:
///
/// * shape: array dimensions
/// * dtype: data type string (e.g., "float32", "int16")
/// * strides: byte offsets for each dimension
/// * c_contiguous/f_contiguous: memory layout flags
///
/// Example (stereo audio float32 array):
/// NumpyBuffer {
/// data: <raw bytes>,
/// shape: \[960, 2\],
/// dtype: "float32",
/// strides: \[8, 4\],
/// c_contiguous: true,
/// f_contiguous: false
/// }
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NumpyBuffer {
    /// Raw array data (bytes)
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// Array shape (dimensions)
    /// Example: \[960\] for 1D, \[960, 2\] for stereo audio
    #[prost(uint64, repeated, tag = "2")]
    pub shape: ::prost::alloc::vec::Vec<u64>,
    /// Data type string
    /// Examples: "float32", "float64", "int16", "int32", "uint8"
    #[prost(string, tag = "3")]
    pub dtype: ::prost::alloc::string::String,
    /// Array strides (bytes to step in each dimension)
    /// Critical for memory layout reconstruction
    #[prost(int64, repeated, tag = "4")]
    pub strides: ::prost::alloc::vec::Vec<i64>,
    /// Whether array is C-contiguous (row-major)
    #[prost(bool, tag = "5")]
    pub c_contiguous: bool,
    /// Whether array is Fortran-contiguous (column-major)
    #[prost(bool, tag = "6")]
    pub f_contiguous: bool,
}
/// File reference with metadata and byte range support
///
/// Represents a reference to a file on the local filesystem.
/// Does NOT contain file contents - only metadata for referencing.
///
/// Usage patterns:
///
/// 1. Simple reference: path only, metadata optional
/// 1. Byte range read: path + offset + length
/// 1. Output file: path + stream_id for multi-track routing
///
/// Example (input file reference):
/// FileBuffer {
/// path: "/data/input/video.mp4",
/// filename: "video.mp4",
/// mime_type: "video/mp4",
/// size: 104857600  // 100 MB
/// }
///
/// Example (byte range request):
/// FileBuffer {
/// path: "/data/input/video.mp4",
/// offset: 1048576,  // 1 MB offset
/// length: 65536     // 64 KB chunk
/// }
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FileBuffer {
    /// File path (required, UTF-8)
    /// May be absolute (/path/to/file) or relative (./file)
    /// Path resolution is responsibility of processing node
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// Original filename (optional)
    /// Preserved separately from path for cases where the filename
    /// should be maintained independent of storage location
    /// Empty string = not specified (use path basename)
    #[prost(string, tag = "2")]
    pub filename: ::prost::alloc::string::String,
    /// MIME type hint (optional)
    /// RFC 6838 format: type/subtype (e.g., "video/mp4", "image/png")
    /// Empty string = not specified (node may auto-detect)
    #[prost(string, tag = "3")]
    pub mime_type: ::prost::alloc::string::String,
    /// File size in bytes (optional)
    /// 0 = unknown (common for output files before writing)
    #[prost(uint64, tag = "4")]
    pub size: u64,
    /// Byte offset for range read/write (optional)
    /// 0 = start of file (default behavior)
    /// Used for seeking to specific positions in media files
    #[prost(uint64, tag = "5")]
    pub offset: u64,
    /// Length for range requests (optional)
    /// 0 = read/write to end of file (default behavior)
    /// Used with offset for partial file I/O
    #[prost(uint64, tag = "6")]
    pub length: u64,
    /// Stream identifier for multi-track routing (optional)
    /// Follows same pattern as Audio/Video stream_id (spec 013)
    /// Empty string = default track
    #[prost(string, tag = "7")]
    pub stream_id: ::prost::alloc::string::String,
}
/// Control message for pipeline flow control
///
/// Enables low-latency optimizations:
///
/// * CancelSpeculation: Cancel processing of speculative audio segments
/// * BatchHint: Suggest batching parameters to downstream nodes
/// * DeadlineWarning: Signal approaching soft deadlines
///
/// Example (Cancel speculation):
/// ControlMessage {
/// message_type: { cancel_speculation: { from_timestamp: 1000, to_timestamp: 2000 } },
/// segment_id: "seg_abc123",
/// timestamp_ms: 1500
/// }
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ControlMessage {
    /// Optional target segment ID for cancellation
    #[prost(string, tag = "4")]
    pub segment_id: ::prost::alloc::string::String,
    /// Message creation timestamp (milliseconds since epoch)
    #[prost(uint64, tag = "5")]
    pub timestamp_ms: u64,
    /// Extensible metadata (JSON encoded)
    /// Example: {"reason": "vad_false_positive", "confidence": 0.3}
    #[prost(string, tag = "6")]
    pub metadata: ::prost::alloc::string::String,
    /// Control message type (exactly one must be set)
    #[prost(oneof = "control_message::MessageType", tags = "1, 2, 3")]
    pub message_type: ::core::option::Option<control_message::MessageType>,
}
/// Nested message and enum types in `ControlMessage`.
pub mod control_message {
    /// Control message type (exactly one must be set)
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum MessageType {
        #[prost(message, tag = "1")]
        CancelSpeculation(super::CancelSpeculation),
        #[prost(message, tag = "2")]
        BatchHint(super::BatchHint),
        #[prost(message, tag = "3")]
        DeadlineWarning(super::DeadlineWarning),
    }
}
/// Cancel a speculative segment (retroactive cancellation)
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CancelSpeculation {
    /// Start timestamp of segment to cancel (sample index or microseconds)
    #[prost(uint64, tag = "1")]
    pub from_timestamp: u64,
    /// End timestamp of segment to cancel
    #[prost(uint64, tag = "2")]
    pub to_timestamp: u64,
}
/// Hint to increase batch size for throughput
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchHint {
    /// Suggested batch size for downstream nodes
    #[prost(uint32, tag = "1")]
    pub suggested_batch_size: u32,
}
/// Soft deadline approaching (not a hard timeout)
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeadlineWarning {
    /// Deadline in microseconds from now
    #[prost(uint64, tag = "1")]
    pub deadline_us: u64,
}
/// Performance metrics for pipeline execution
///
/// UPDATED: Added serialization_time_ms and data_type_breakdown
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionMetrics {
    /// Wall-clock time from request receipt to response ready (milliseconds)
    /// Target: \<5ms for simple operations (SC-001)
    #[prost(double, tag = "1")]
    pub wall_time_ms: f64,
    /// Total CPU time consumed by all threads (milliseconds)
    #[prost(double, tag = "2")]
    pub cpu_time_ms: f64,
    /// Peak memory usage during execution (bytes)
    /// Target: \<10MB per concurrent execution (SC-008)
    #[prost(uint64, tag = "3")]
    pub memory_used_bytes: u64,
    /// Per-node execution statistics (keyed by node ID)
    #[prost(map = "string, message", tag = "4")]
    pub node_metrics: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        NodeMetrics,
    >,
    /// Time spent serializing/deserializing protobuf messages (milliseconds)
    /// Target: \<10% of wall_time_ms (SC-003)
    #[prost(double, tag = "5")]
    pub serialization_time_ms: f64,
    /// NEW: Proto ↔ Runtime conversion overhead
    /// Measures DataBuffer → RuntimeData → DataBuffer conversion time
    #[prost(double, tag = "6")]
    pub proto_to_runtime_ms: f64,
    #[prost(double, tag = "7")]
    pub runtime_to_proto_ms: f64,
    /// NEW: Track data type distribution
    /// Keys: "audio", "video", "tensor", "json", "text", "binary"
    /// Values: Count of chunks/buffers processed per type
    #[prost(map = "string, uint64", tag = "8")]
    pub data_type_breakdown: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        u64,
    >,
}
/// Performance metrics for a single node execution
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeMetrics {
    /// Time spent executing this node's process() method (milliseconds)
    #[prost(double, tag = "1")]
    pub execution_time_ms: f64,
    /// Memory allocated by this node (bytes)
    #[prost(uint64, tag = "2")]
    pub memory_bytes: u64,
    /// UPDATED: Generic item count (was samples_processed)
    /// Audio: samples, Video: frames, Tensor: elements, JSON: objects, Text: characters
    #[prost(uint64, tag = "3")]
    pub items_processed: u64,
    /// Node-specific metrics (JSON encoded)
    /// Example: {"vad_segments": 12, "silence_ratio": 0.45}
    #[prost(string, tag = "4")]
    pub custom_metrics: ::prost::alloc::string::String,
}
/// Structured error information for debugging and diagnostics
///
/// UPDATED: Added ERROR_TYPE_TYPE_VALIDATION for generic type errors
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ErrorResponse {
    /// Error category for programmatic handling
    #[prost(enumeration = "ErrorType", tag = "1")]
    pub error_type: i32,
    /// Human-readable error message
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// Node ID where error occurred (empty for manifest validation errors)
    #[prost(string, tag = "3")]
    pub failing_node_id: ::prost::alloc::string::String,
    /// Execution context at time of error (JSON encoded)
    /// Example: {"expected_type": "AUDIO", "actual_type": "VIDEO"}
    #[prost(string, tag = "4")]
    pub context: ::prost::alloc::string::String,
    /// Rust panic stack trace (if available)
    #[prost(string, tag = "5")]
    pub stack_trace: ::prost::alloc::string::String,
}
/// Service version and protocol compatibility information
///
/// Returned by GetVersion() RPC to enable client compatibility checks.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VersionInfo {
    /// Current protocol version (e.g., "v1")
    #[prost(string, tag = "1")]
    pub protocol_version: ::prost::alloc::string::String,
    /// Rust runtime version (e.g., "0.2.1")
    #[prost(string, tag = "2")]
    pub runtime_version: ::prost::alloc::string::String,
    /// List of supported node types registered in this service
    /// Example: \["AudioResample", "VAD", "HFPipelineNode"\]
    #[prost(string, repeated, tag = "3")]
    pub supported_node_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// All protocol versions this service supports
    /// Example: \["v1"\] initially, may expand to \["v1", "v2"\]
    #[prost(string, repeated, tag = "4")]
    pub supported_protocols: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Service build timestamp (ISO 8601)
    /// Example: "2025-10-28T10:30:00Z"
    #[prost(string, tag = "5")]
    pub build_timestamp: ::prost::alloc::string::String,
}
/// Configurable resource constraints for pipeline execution
///
/// Clients can request custom limits within service-defined maximums.
/// Service applies defaults if not specified.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResourceLimits {
    /// Maximum memory allocation (bytes)
    /// Default: 100MB, Max: 1GB (configurable per service)
    #[prost(uint64, tag = "1")]
    pub max_memory_bytes: u64,
    /// Maximum execution timeout (milliseconds)
    /// Default: 5000ms, Max: 30000ms (configurable per service)
    #[prost(uint64, tag = "2")]
    pub max_timeout_ms: u64,
    /// Maximum audio buffer size (samples, across all channels)
    /// Default: 10M samples (~200MB stereo F32)
    /// Prevents out-of-memory attacks
    #[prost(uint64, tag = "3")]
    pub max_audio_samples: u64,
}
/// Execution details for a single node
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NodeResult {
    /// Node ID from manifest
    #[prost(string, tag = "1")]
    pub node_id: ::prost::alloc::string::String,
    /// Execution status
    #[prost(enumeration = "NodeStatus", tag = "2")]
    pub status: i32,
    /// Error details (only if status == NODE_STATUS_FAILED)
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<ErrorResponse>,
    /// Node-specific output metadata (JSON encoded)
    /// Example: {"output_format": "f32", "channels": 2}
    #[prost(string, tag = "4")]
    pub output_metadata: ::prost::alloc::string::String,
}
/// Audio sample encoding format
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AudioFormat {
    Unspecified = 0,
    /// 32-bit floating point, range \[-1.0, 1.0\]
    /// 4 bytes per sample
    F32 = 1,
    /// 16-bit signed integer, range \[-32768, 32767\]
    /// 2 bytes per sample (most common format)
    I16 = 2,
    /// 32-bit signed integer
    /// 4 bytes per sample
    I32 = 3,
}
impl AudioFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "AUDIO_FORMAT_UNSPECIFIED",
            Self::F32 => "AUDIO_FORMAT_F32",
            Self::I16 => "AUDIO_FORMAT_I16",
            Self::I32 => "AUDIO_FORMAT_I32",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AUDIO_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
            "AUDIO_FORMAT_F32" => Some(Self::F32),
            "AUDIO_FORMAT_I16" => Some(Self::I16),
            "AUDIO_FORMAT_I32" => Some(Self::I32),
            _ => None,
        }
    }
}
/// Pixel format enumeration
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PixelFormat {
    Unspecified = 0,
    /// Packed RGB, 8-bit per channel (3 bytes/pixel)
    /// Layout: \[R, G, B, R, G, B, ...\]
    Rgb24 = 1,
    /// Packed RGBA, 8-bit per channel (4 bytes/pixel)
    /// Layout: \[R, G, B, A, R, G, B, A, ...\]
    Rgba32 = 2,
    /// Planar YUV 4:2:0 (1.5 bytes/pixel)
    /// Y plane: width*height, U plane: (width/2)*(height/2), V plane: same as U
    Yuv420p = 3,
    /// Grayscale, 8-bit (1 byte/pixel)
    Gray8 = 4,
    /// I420 format (identical to YUV420P, WebRTC compatibility)
    I420 = 5,
    /// NV12 semi-planar (Y plane + interleaved UV)
    Nv12 = 6,
    /// Encoded bitstream (not raw pixels)
    Encoded = 255,
}
impl PixelFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PIXEL_FORMAT_UNSPECIFIED",
            Self::Rgb24 => "PIXEL_FORMAT_RGB24",
            Self::Rgba32 => "PIXEL_FORMAT_RGBA32",
            Self::Yuv420p => "PIXEL_FORMAT_YUV420P",
            Self::Gray8 => "PIXEL_FORMAT_GRAY8",
            Self::I420 => "PIXEL_FORMAT_I420",
            Self::Nv12 => "PIXEL_FORMAT_NV12",
            Self::Encoded => "PIXEL_FORMAT_ENCODED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PIXEL_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
            "PIXEL_FORMAT_RGB24" => Some(Self::Rgb24),
            "PIXEL_FORMAT_RGBA32" => Some(Self::Rgba32),
            "PIXEL_FORMAT_YUV420P" => Some(Self::Yuv420p),
            "PIXEL_FORMAT_GRAY8" => Some(Self::Gray8),
            "PIXEL_FORMAT_I420" => Some(Self::I420),
            "PIXEL_FORMAT_NV12" => Some(Self::Nv12),
            "PIXEL_FORMAT_ENCODED" => Some(Self::Encoded),
            _ => None,
        }
    }
}
/// Video codec enumeration (Spec 012: Video Codec Support)
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VideoCodec {
    Unspecified = 0,
    /// VP8 (WebM, WebRTC standard, royalty-free)
    /// RFC 6386
    Vp8 = 1,
    /// H.264/AVC (widely supported, hardware acceleration)
    /// ITU-T H.264
    H264 = 2,
    /// AV1 (next-gen royalty-free, superior compression)
    Av1 = 3,
}
impl VideoCodec {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "VIDEO_CODEC_UNSPECIFIED",
            Self::Vp8 => "VIDEO_CODEC_VP8",
            Self::H264 => "VIDEO_CODEC_H264",
            Self::Av1 => "VIDEO_CODEC_AV1",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VIDEO_CODEC_UNSPECIFIED" => Some(Self::Unspecified),
            "VIDEO_CODEC_VP8" => Some(Self::Vp8),
            "VIDEO_CODEC_H264" => Some(Self::H264),
            "VIDEO_CODEC_AV1" => Some(Self::Av1),
            _ => None,
        }
    }
}
/// Tensor data type enumeration
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TensorDtype {
    Unspecified = 0,
    /// 32-bit float (4 bytes per element)
    F32 = 1,
    /// 16-bit float (2 bytes per element)
    F16 = 2,
    /// 32-bit int (4 bytes per element)
    I32 = 3,
    /// 8-bit int (1 byte per element, quantized models)
    I8 = 4,
    /// 8-bit unsigned int (1 byte per element)
    U8 = 5,
}
impl TensorDtype {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TENSOR_DTYPE_UNSPECIFIED",
            Self::F32 => "TENSOR_DTYPE_F32",
            Self::F16 => "TENSOR_DTYPE_F16",
            Self::I32 => "TENSOR_DTYPE_I32",
            Self::I8 => "TENSOR_DTYPE_I8",
            Self::U8 => "TENSOR_DTYPE_U8",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TENSOR_DTYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "TENSOR_DTYPE_F32" => Some(Self::F32),
            "TENSOR_DTYPE_F16" => Some(Self::F16),
            "TENSOR_DTYPE_I32" => Some(Self::I32),
            "TENSOR_DTYPE_I8" => Some(Self::I8),
            "TENSOR_DTYPE_U8" => Some(Self::U8),
            _ => None,
        }
    }
}
/// Data type hint for compile-time and runtime type validation
///
/// Used in NodeManifest to declare expected input/output types.
/// Enables three-layer validation:
///
/// 1. Compile-time: TypeScript/Python type checking
/// 1. Manifest validation: Connection type compatibility at StreamInit
/// 1. Runtime: Chunk type validation per chunk
///
/// Example (VAD node: audio in, JSON out):
/// NodeManifest {
/// id: "vad",
/// node_type: "RustVADNode",
/// input_types: \[DATA_TYPE_HINT_AUDIO\],
/// output_types: \[DATA_TYPE_HINT_JSON\]
/// }
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DataTypeHint {
    Unspecified = 0,
    Audio = 1,
    Video = 2,
    Tensor = 3,
    Json = 4,
    Text = 5,
    Binary = 6,
    /// Accept any type (polymorphic node)
    /// Example: generic logger, passthrough, inspector
    Any = 7,
    /// File reference (Spec 001: RuntimeData.File)
    File = 8,
}
impl DataTypeHint {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DATA_TYPE_HINT_UNSPECIFIED",
            Self::Audio => "DATA_TYPE_HINT_AUDIO",
            Self::Video => "DATA_TYPE_HINT_VIDEO",
            Self::Tensor => "DATA_TYPE_HINT_TENSOR",
            Self::Json => "DATA_TYPE_HINT_JSON",
            Self::Text => "DATA_TYPE_HINT_TEXT",
            Self::Binary => "DATA_TYPE_HINT_BINARY",
            Self::Any => "DATA_TYPE_HINT_ANY",
            Self::File => "DATA_TYPE_HINT_FILE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATA_TYPE_HINT_UNSPECIFIED" => Some(Self::Unspecified),
            "DATA_TYPE_HINT_AUDIO" => Some(Self::Audio),
            "DATA_TYPE_HINT_VIDEO" => Some(Self::Video),
            "DATA_TYPE_HINT_TENSOR" => Some(Self::Tensor),
            "DATA_TYPE_HINT_JSON" => Some(Self::Json),
            "DATA_TYPE_HINT_TEXT" => Some(Self::Text),
            "DATA_TYPE_HINT_BINARY" => Some(Self::Binary),
            "DATA_TYPE_HINT_ANY" => Some(Self::Any),
            "DATA_TYPE_HINT_FILE" => Some(Self::File),
            _ => None,
        }
    }
}
/// Error category enumeration
///
/// UPDATED: Added ERROR_TYPE_TYPE_VALIDATION
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorType {
    Unspecified = 0,
    /// Manifest validation error (malformed JSON, invalid node IDs, cycles)
    /// Action: Fix manifest and retry
    Validation = 1,
    /// Node execution failure (invalid parameters, processing error)
    /// Action: Check node parameters and input data
    NodeExecution = 2,
    /// Resource limit exceeded (memory, timeout, buffer size)
    /// Action: Reduce pipeline complexity or request higher limits
    ResourceLimit = 3,
    /// Authentication failed (invalid/missing API token)
    /// Action: Check API token configuration
    Authentication = 4,
    /// Protocol version mismatch (incompatible client/server versions)
    /// Action: Upgrade client library
    VersionMismatch = 5,
    /// Service internal error (panic, unexpected state)
    /// Action: Retry with exponential backoff, contact support if persistent
    Internal = 6,
    /// NEW: Type validation error (type mismatch in manifest or runtime)
    /// Action: Fix type declarations or data types
    /// Example: Audio node receives video data
    TypeValidation = 7,
}
impl ErrorType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ERROR_TYPE_UNSPECIFIED",
            Self::Validation => "ERROR_TYPE_VALIDATION",
            Self::NodeExecution => "ERROR_TYPE_NODE_EXECUTION",
            Self::ResourceLimit => "ERROR_TYPE_RESOURCE_LIMIT",
            Self::Authentication => "ERROR_TYPE_AUTHENTICATION",
            Self::VersionMismatch => "ERROR_TYPE_VERSION_MISMATCH",
            Self::Internal => "ERROR_TYPE_INTERNAL",
            Self::TypeValidation => "ERROR_TYPE_TYPE_VALIDATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ERROR_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ERROR_TYPE_VALIDATION" => Some(Self::Validation),
            "ERROR_TYPE_NODE_EXECUTION" => Some(Self::NodeExecution),
            "ERROR_TYPE_RESOURCE_LIMIT" => Some(Self::ResourceLimit),
            "ERROR_TYPE_AUTHENTICATION" => Some(Self::Authentication),
            "ERROR_TYPE_VERSION_MISMATCH" => Some(Self::VersionMismatch),
            "ERROR_TYPE_INTERNAL" => Some(Self::Internal),
            "ERROR_TYPE_TYPE_VALIDATION" => Some(Self::TypeValidation),
            _ => None,
        }
    }
}
/// Overall pipeline execution status
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExecutionStatus {
    Unspecified = 0,
    /// All nodes executed successfully
    Success = 1,
    /// Some nodes were skipped but pipeline completed
    /// (e.g., conditional nodes based on input data)
    PartialSuccess = 2,
    /// Pipeline execution failed (see ErrorResponse for details)
    Failed = 3,
}
impl ExecutionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "EXECUTION_STATUS_UNSPECIFIED",
            Self::Success => "EXECUTION_STATUS_SUCCESS",
            Self::PartialSuccess => "EXECUTION_STATUS_PARTIAL_SUCCESS",
            Self::Failed => "EXECUTION_STATUS_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EXECUTION_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "EXECUTION_STATUS_SUCCESS" => Some(Self::Success),
            "EXECUTION_STATUS_PARTIAL_SUCCESS" => Some(Self::PartialSuccess),
            "EXECUTION_STATUS_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
/// Execution status for a single node
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NodeStatus {
    Unspecified = 0,
    /// Node executed successfully
    Success = 1,
    /// Node was skipped (conditional execution)
    Skipped = 2,
    /// Node execution failed (see ErrorResponse for details)
    Failed = 3,
}
impl NodeStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NODE_STATUS_UNSPECIFIED",
            Self::Success => "NODE_STATUS_SUCCESS",
            Self::Skipped => "NODE_STATUS_SKIPPED",
            Self::Failed => "NODE_STATUS_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NODE_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "NODE_STATUS_SUCCESS" => Some(Self::Success),
            "NODE_STATUS_SKIPPED" => Some(Self::Skipped),
            "NODE_STATUS_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
