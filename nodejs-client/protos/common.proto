// Common protocol buffer types for Rust gRPC service
// Feature: 003-rust-grpc-service
// 
// This file contains shared types used across multiple RPCs:
// - AudioBuffer: Multi-channel audio data with metadata
// - ExecutionMetrics: Performance measurements
// - ErrorResponse: Structured error information
// - VersionInfo: Service version and compatibility

syntax = "proto3";

package remotemedia.v1;

// ============================================================================
// Audio Types
// ============================================================================

// Multi-channel audio data with sample rate and format metadata
//
// Samples are stored in interleaved format for multi-channel audio.
// For stereo: [L0, R0, L1, R1, L2, R2, ...]
message AudioBuffer {
  // Raw audio samples (interleaved, little-endian)
  // Size = num_samples * format.bytes_per_sample()
  bytes samples = 1;

  // Sample rate in Hz (e.g., 8000, 16000, 44100, 48000)
  uint32 sample_rate = 2;

  // Number of channels (1=mono, 2=stereo, 6=5.1 surround)
  uint32 channels = 3;

  // Audio sample encoding format
  AudioFormat format = 4;

  // Total number of samples (including all channels)
  // num_frames = num_samples / channels
  // duration_seconds = num_frames / sample_rate
  uint64 num_samples = 5;
}

// Audio sample encoding format
enum AudioFormat {
  AUDIO_FORMAT_UNSPECIFIED = 0;
  
  // 32-bit floating point, range [-1.0, 1.0]
  // 4 bytes per sample
  AUDIO_FORMAT_F32 = 1;
  
  // 16-bit signed integer, range [-32768, 32767]
  // 2 bytes per sample (most common format)
  AUDIO_FORMAT_I16 = 2;
  
  // 32-bit signed integer
  // 4 bytes per sample
  AUDIO_FORMAT_I32 = 3;
}

// ============================================================================
// Metrics Types
// ============================================================================

// Performance metrics for pipeline execution
//
// Tracks wall-clock time, CPU time, memory usage, and per-node statistics.
// Used for performance monitoring and optimization.
message ExecutionMetrics {
  // Wall-clock time from request receipt to response ready (milliseconds)
  // Target: <5ms for simple operations (SC-001)
  double wall_time_ms = 1;

  // Total CPU time consumed by all threads (milliseconds)
  double cpu_time_ms = 2;

  // Peak memory usage during execution (bytes)
  // Target: <10MB per concurrent execution (SC-008)
  uint64 memory_used_bytes = 3;

  // Per-node execution statistics (keyed by node ID)
  map<string, NodeMetrics> node_metrics = 4;

  // Time spent serializing/deserializing protobuf messages (milliseconds)
  // Target: <10% of wall_time_ms (SC-003)
  double serialization_time_ms = 5;
}

// Performance metrics for a single node execution
message NodeMetrics {
  // Time spent executing this node's process() method (milliseconds)
  double execution_time_ms = 1;

  // Memory allocated by this node (bytes)
  uint64 memory_bytes = 2;

  // Total audio samples processed (across all channels)
  uint64 samples_processed = 3;

  // Node-specific metrics (JSON encoded)
  // Example: {"vad_segments": 12, "silence_ratio": 0.45}
  string custom_metrics = 4;
}

// ============================================================================
// Error Types
// ============================================================================

// Structured error information for debugging and diagnostics
//
// Provides error category, message, context, and stack trace for
// effective troubleshooting.
message ErrorResponse {
  // Error category for programmatic handling
  ErrorType error_type = 1;

  // Human-readable error message
  string message = 2;

  // Node ID where error occurred (empty for manifest validation errors)
  string failing_node_id = 3;

  // Execution context at time of error (JSON encoded)
  // Example: {"input_sample_rate": 44100, "target_sample_rate": -1}
  string context = 4;

  // Rust panic stack trace (if available)
  string stack_trace = 5;
}

// Error category enumeration
//
// Used by clients for error handling logic (retry, fix manifest, etc.)
enum ErrorType {
  ERROR_TYPE_UNSPECIFIED = 0;

  // Manifest validation error (malformed JSON, invalid node IDs, cycles)
  // Action: Fix manifest and retry
  ERROR_TYPE_VALIDATION = 1;

  // Node execution failure (invalid parameters, processing error)
  // Action: Check node parameters and input data
  ERROR_TYPE_NODE_EXECUTION = 2;

  // Resource limit exceeded (memory, timeout, buffer size)
  // Action: Reduce pipeline complexity or request higher limits
  ERROR_TYPE_RESOURCE_LIMIT = 3;

  // Authentication failed (invalid/missing API token)
  // Action: Check API token configuration
  ERROR_TYPE_AUTHENTICATION = 4;

  // Protocol version mismatch (incompatible client/server versions)
  // Action: Upgrade client library
  ERROR_TYPE_VERSION_MISMATCH = 5;

  // Service internal error (panic, unexpected state)
  // Action: Retry with exponential backoff, contact support if persistent
  ERROR_TYPE_INTERNAL = 6;
}

// ============================================================================
// Version Types
// ============================================================================

// Service version and protocol compatibility information
//
// Returned by GetVersion() RPC to enable client compatibility checks.
message VersionInfo {
  // Current protocol version (e.g., "v1")
  string protocol_version = 1;

  // Rust runtime version (e.g., "0.2.1")
  string runtime_version = 2;

  // List of supported node types registered in this service
  // Example: ["AudioResample", "VAD", "HFPipelineNode"]
  repeated string supported_node_types = 3;

  // All protocol versions this service supports
  // Example: ["v1"] initially, may expand to ["v1", "v2"]
  repeated string supported_protocols = 4;

  // Service build timestamp (ISO 8601)
  // Example: "2025-10-28T10:30:00Z"
  string build_timestamp = 5;
}

// ============================================================================
// Resource Types
// ============================================================================

// Configurable resource constraints for pipeline execution
//
// Clients can request custom limits within service-defined maximums.
// Service applies defaults if not specified.
message ResourceLimits {
  // Maximum memory allocation (bytes)
  // Default: 100MB, Max: 1GB (configurable per service)
  uint64 max_memory_bytes = 1;

  // Maximum execution timeout (milliseconds)
  // Default: 5000ms, Max: 30000ms (configurable per service)
  uint64 max_timeout_ms = 2;

  // Maximum audio buffer size (samples, across all channels)
  // Default: 10M samples (~200MB stereo F32)
  // Prevents out-of-memory attacks
  uint64 max_audio_samples = 3;
}

// ============================================================================
// Execution Status Types
// ============================================================================

// Overall pipeline execution status
enum ExecutionStatus {
  EXECUTION_STATUS_UNSPECIFIED = 0;
  
  // All nodes executed successfully
  EXECUTION_STATUS_SUCCESS = 1;
  
  // Some nodes were skipped but pipeline completed
  // (e.g., conditional nodes based on input data)
  EXECUTION_STATUS_PARTIAL_SUCCESS = 2;
  
  // Pipeline execution failed (see ErrorResponse for details)
  EXECUTION_STATUS_FAILED = 3;
}

// Execution status for a single node
enum NodeStatus {
  NODE_STATUS_UNSPECIFIED = 0;
  
  // Node executed successfully
  NODE_STATUS_SUCCESS = 1;
  
  // Node was skipped (conditional execution)
  NODE_STATUS_SKIPPED = 2;
  
  // Node execution failed (see ErrorResponse for details)
  NODE_STATUS_FAILED = 3;
}

// Execution details for a single node
message NodeResult {
  // Node ID from manifest
  string node_id = 1;

  // Execution status
  NodeStatus status = 2;

  // Error details (only if status == NODE_STATUS_FAILED)
  ErrorResponse error = 3;

  // Node-specific output metadata (JSON encoded)
  // Example: {"output_format": "f32", "channels": 2}
  string output_metadata = 4;
}
